# 内存管理

## 虚拟内存

操作系统为每个进程分配独立的一套 **虚拟地址**，并提供一种机制，将不同的虚拟地址和不同内存的物理地址映射起来。具体的映射由 MMU 完成。

两种地址：

* 虚拟内存地址：程序所使用的内存地址
* 物理内存地址：实际存在硬件里面的空间地址

## 内存分段

分段机制下，虚拟地址由 **段选择子** 和 **段内偏移量** 组成：

* 段选择子：由段寄存器保存，**段号**，用作段表的索引，**段表** 保存 **段的基地址、界限和特权等级**
* 段内偏移量：位于 0 与段界限之间，段基地址加上段内偏移量即为物理内存地址

分段机制的不足：

* 内存碎片
* 内存交换效率低

内存碎片分为外部碎片和内部碎片，解决外部碎片的方案是 **内存交换**，而内存交换是在内存与硬盘之间交换，硬盘响应速度过慢，如果需要交换的内存过大，会导致系统卡顿，由此，出现了 **内存分页**。

## 内存分页

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。Linux 下，每一页的大小为 `4KB`。

虚拟地址与物理地址之间通过 **页表** 映射。页表存储在 CPU 的 **内存管理单元(MMU)** 中。

分页机制下，虚拟地址由 **页号** 和 **页内偏移** 组成：

* 页号：页号是页表的索引，**页表** 包含物理页每页所在 **物理内存的基地址**
* 页内偏移：与页基地址组合形成物理内存地址

页表需要存储在内存中，比如，32 位机器上，虚拟内存为 4GB，每页大小为 4KB，则需要 2^20 个页表项，每个页表项占 4 字节，则一个页表需要占 4 * 2^20 = 4MB 空间。若同时运行 100 个进程，那么需要 400 MB 内存来存储页表，若在 64 位机器上，则需要更大的内存空间存储页表，由此，产生了 **多级页表**。多级页表结合计算机 **局部性原理**，可以减少页表的内存占用。根据局部性原理，大多数情况下，只需要创建一级页表，然后在需要的时候才创建二级页表。对于 64 位系统，两级分页也不够，需要四级分页：

* 全局页目录项 PGD
* 上层页目录项 PUD
* 中间页目录项 PMD
* 页表项 PTD

**TLB**：Translation Lookaside Buffer，通常称页表缓存、转址旁路缓存、快表，是 CPU 芯片中专门存放程序最常访问的页表项的 Cache。

## 段页式内存管理

实现方式：

* 先将程序划分为多个有逻辑意义的段，即分段机制
* 再把每个段划分为多个页

这样，地址结构就由 **段号、段内页号、页内偏移** 三部分组成。